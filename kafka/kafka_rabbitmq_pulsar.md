# 消息队列中间件对比与选型

消息队列中间件（简称消息中间件）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。

目前开源的消息中间件可谓是琳琅满目，本文针对性的挑选常见的 RabbitMQ 和 Kafka 两款典型的消息中间件来做分析和对比，阐述消息中间件选型中的各个要点。也会对比 Pulsar 这个比较新的消息中间件和 RabbitMQ 和 Kafka 的异同。

## 对比要点说明

消息中间件的对比主要从以下几个维度进行对比，说明 RabbitMQ 和 Kafka 在以下维度的支持情况以及区别。

1. 功能
2. 性能
3. 可靠性和可用性
4. 运维管理
5. 社区力度及生态发展

其中在功能维度方面，主要从生产消息、消息堆积和持久化、消费消息、其他功能等几方面说明各中间之间的差异。在性能维度，主要说明各中间在吞吐量以及延迟方面的对比。

## 功能维度

### 生产消息

消息发布是消息通信架构的核心活动之一，消息发布涉及很多方面。应用程序可以使用很多消息发布选项，这些选项可能会对应用程序的性能和可靠性产生巨大影响。虽然性能和吞吐量可以用来衡量任何消息代理服务器，但是我们最关注的是消息的可靠投递。

消息的可靠投递包括如下几方面：

1. 不可投递(路由)的消息处理

当向消息代理服务器发送消息时，如果消息代理服务器正确投递消息，例如 kafka broker 不能将消息投递到正确的分区或者 rabbitmq 不能将消息路由到正确的队列，此时就会面临丢失数据的风险。

kafka 通过在客户端库中实现定时获取集群元数据，支持同步和异步发送数据两种方式以及设计若干异常来保证消息的可靠投递

rabbitmq 通过在发送数据时设置 mandatory 参数，设置备用交换机等方式保证消息的正确投递。

2. 事务

事务是由事务开始（Begin Transaction）和事务结束（End Transaction）之间执行的全体操作组成。消息代理服务器的事务支持是指生产者发生消息的事务，要么发送成功，要么发送失败。Kafka 和 RabbitMQ 都支持事务。

3. 生产消息流量控制

生产消息流量控制主要针对的是发送方与消息代理服务器处理能力速率不匹配的问题，这是需要抑制发送方发送消息的速率。确保系统稳定。

kafka 主要使用配置用户或者客户端生产速率的方式确保发送方发送消息的速率不超过一定的水平。但这个功能会严重影响性能，并且不是很稳定。

rabbitmq 使用 broker 向生产者发送回推消息的方式抑制生产者发送消息，直到 broker 再次发送回推消息才继续发送消息。

### 消息堆积和持久化

当消息代理服务器接收消息以后，消息代理服务器需要提供一定的消息堆积或者持久化的能力，如果没有该能力，消息的消费者还没来得及消费该消息，消息就丢失了，显然这不是一个合格的消息代理服务器。

消息堆积分内存式堆积和磁盘式堆积。RabbitMQ 是典型的内存式堆积，并且在某些配置或者条件触发下，消息会被持久化到磁盘上。Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。

kafka 通过分区副本的功能提供数据冗余的功能，确保数据高可用。rabbitmq 通过 HA 队列的方式也提供数据冗余的功能。

### 消费消息

消息消费也是消息通信架构的核心活动之一，在消息消费方面，支持高性能的消费模式和满足不同的消费场景是消息代理服务器的重要功能，具体表现在一下几方面：

1. 消费模式

消费模式分为推（push）模式和拉（pull）模式。推模式是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。而拉模式是指消费端主动向 Broker 端请求拉取（一般是定时或者定量）消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。

kafka 支持的是拉模式，rabbitmq 支持推拉两种模式。

2. 死信队列

当消费者拒绝消息代理服务器投递过来的消息时，例如因为消息格式错误导致消费者不能正确处理该消息，消费者拒绝这条消息，如果消息代理服务器直接将拒绝的消息删除有可能无法回溯找到消息格式错误的原因，如果将消息重新投递到一个专有队列，定期分析专有队列中的消息，就有可能发现格式错误的原因。因此死信队列在实际应用中有广泛用途。

目前 rabbitmq 通过配置死信交换机支持死信队列的功能，kafka 目前不支持相关功能。

3. 优先级队列

优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。

目前 rabbitmq 支持优先级队列，kafka 不支持优先级相关概念。

4. 延迟队列

延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。实际应用中大多采用基于队列的延迟，设置不同延迟级别的队列，比如 5s、10s、30s、1min、5mins、10mins 等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略（比如定时）即可投递超时的消息。

目前 rabbitmq 支持延迟队列，kafka 不支持延迟相关概念。

5. 消息回溯

一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。

kafka 通过重置消费者消息偏移量实现消息回溯的功能，rabbitmq 不支持消息回溯功能。

6. 消息追踪

对于消息追踪最通俗的理解就是要知道消息从哪来，存在哪里以及发往哪里去。基于此功能下，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。

rabbitmq 通过 rabbitmq_tracing 或者 firehose 等插件实现消息追踪功能，但这个会严重影响性能。kafka 不支持消息追踪功能。

7. 消息顺序性

消息顺序性是指保证消息有序。kafka 支持在单分区上的顺序性，或者通过特定配置支持在整个 topic 上的顺序性。rabbitmq 支持的消息顺序性依赖生产者逻辑和配置，在一定程度上来说并不支持消息顺序性。

8. 消息幂等性

消息在生产者和消费者之间进行传输而言一般有三种传输保障：At most once，至多一次，消息可能丢失，但绝不会重复传输；At least once，至少一次，消息绝不会丢，但是可能会重复；Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。

对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障。kafka 通过引入全局唯一标识符和事务的机制支持 Exactly once 传输保障。

### 其他

1. 多租户

多租户主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。

RabbitMQ 能够支持多租户，每一个租户表示为一个 vhost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。vhost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。

kafka 不支持多租户功能。

2. 多协议支持

消息是信息的载体，为了让生产者和消费者都能理解所承载的信息（生产者需要知道如何构造消息，消费者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。有效的消息一定具有某种格式，而没有格式的消息是没有意义的。一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等（消息领域中的 JMS 更多的是一个规范而不是一个协议），支持的协议越多其应用范围就会越广，通用性越强，比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。

3. 跨语言支持

常见的消息代理服务例如 kafka、rabbitmq 等都支持常见的编程语言。

4. 安全机制
安全机制包括身份认证和权限控制两种安全机制。身份认证是指客户端与服务端连接进行身份认证。权限控制是指对客户端的读写操作进行权限控制。

kafka 和 rabbitmq 目前都支持身份认证（TLS/SSL、SASL）和权限控制（读写操作）的安全机制。

### kafka 和 rabbitmq 功能对比

| 功能项 | Kafka | Rabbitmq |
| ----- | ----- | -------- |
| 不可投递(路由)的消息处理 | 支持 | 支持 |
| 事务 | 支持 | 支持 |
| 生产消息流量控制 | 初步支持 | 支持 |
| 消息堆积和持久化 | 支持 | 支持 |
| 消费模式 | kafka 支持的是拉模式 | rabbitmq 支持推拉两种模式 |
| 死信队列 | 不支持 | 支持 |
| 优先级队列 | 不支持 | 支持 |
| 延迟队列 | 不支持 | 支持 |
| 消息回溯 | 支持 | 不支持 |
| 消息追踪 | 不支持 | 通过插件支持 |
| 消息顺序性 | 初步支持 | 初步支持 |
| 消息幂等性 | 支持 | 不支持 |
| 多租户 | 不支持 | 支持 |
| 多协议支持 | 不支持 | 支持 |
| 跨语言支持 | 支持 | 支持 |
| 安全机制  | 支持 | 支持 |

## 性能

通过相关基准测试，在常见平台上各中间件性能指标差异如下：

### 吞吐量

Kafka提供了所有系统中最高的吞吐量，写入速度比RabbitMQ快15倍，比Pulsar快2倍。

### 延迟

Kafka在较高的吞吐量下提供最低的延迟，同时还提供强大的耐用性和高可用性。在所有延迟基准测试中，Kafka的默认配置都比Pulsar更快，并且在每条消息上设置为fsync时，它的速度最高可达p99.9。 RabbitMQ可以实现比Kafka更低的端到端延迟，但仅在吞吐量显着降低的情况下。

## 可靠性和可用性

消息丢失是使用消息中间件时所不得不面对的一个同点，所以消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。然而说到可靠性必然要说到可用性，注意这两者之间的区别，消息中间件的可靠性是指对消息不丢失的保障程度；而消息中间件的可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。

对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR（In-Sync-Replica）来保证多副本之间的同步，并且支持强一致性语义（通过 acks 实现）。

对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。多副本可以保证在 master 节点宕机异常之后可以提升 slave 作为新的 master 而继续提供服务来保障可用性。

就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多。一般来说 rabbitmq 在可靠性和可用性方面略强于 kafka，但此优势并不明显。 

## 运维管理

在消息中间件的使用过程中难免会出现各式各样的异常情况，有客户端的，也有服务端的，那么怎样及时有效的进行监测及修复。业务线流量有峰值又低谷，那么怎样前进行有效的容量评估，如何有效的做好异地多活？这些都离不开消息中间件的衍生产品——运维管理。

运维管理也可以进行进一步的细分，比如：申请、审核、监控、告警、管理、容灾、部署等。

一般来说，目前各中间都有相对比较完善的工具或者插件完成上述任务。

## 社区力度及生态发展

对于目前流行的编程语言而言，如 Java、Python，如果你在使用过程中遇到了一些异常，基本上可以通过搜索引擎的帮助来得到解决，因为一个产品用的人越多，踩过的坑也就越多，对应的解决方案也就越多。对于消息中间件也同样适用，如果你选择了一种“生僻”的消息中间件，可能在某些方面运用的得心应手，但是版本更新缓慢、遇到棘手问题也难以得到社区的支持而越陷越深；相反如果你选择了一种“流行”的消息中间件，其更新力度大，不仅可以迅速的弥补之前的不足，而且也能顺应技术的快速发展来变更一些新的功能，这样可以让你以“站在巨人的肩膀上”。在运维管理维度我们提及了 Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，这些正是得益于其社区及生态的迅猛发展。

## Kafka 与 Rabbitmq 对比总结

Kafka 实现高性能的流式处理，在性能方面有些比较明显的优势，Rabbitmq 实现了灵活的传统队列，在功能方面有一定的优势。

## Pulsar 功能

Pulsar 作为常见的消息代理服务器，Pulsar 的最大优点在于它提供了比 Apache Kafka 更简单明了、更健壮的一系列操作功能，特别在解决可观察性、地域复制和多租户方面的问题。

### 功能对比

从功能方面对比，Pulsar 与 Kafka 有如下几方面的不同：

1. 模型概念

kafka 采用的是 生产者 --> 主题 --> 消费者群组 --> 消费者 的模式。

pulsar 采用的是 生产者 --> 主题 --> 订阅 --> 消费者 的模式。

订阅模式比消费者群组模式更加轻量级，在订阅模式下，消费者的变更会更加快速的完成，因为只需要更新内部数据结构即可，而消费者群组模式在更新内部数据结构的同时还要更新和再平衡消费者元数据信息。

2. 消费模式

Kafka 主要集中在流（Stream）模式，对单个 partition 是独占消费，没有共享（Queue）的消费模式。

Pulsar 提供了统一的消息模型和 API。流（Stream）模式 – 独占和故障切换订阅方式；队列（Queue）模式 – 共享订阅的方式。

3. 消息确认（Ack）

Kafka 使用偏移 Offset。

Pulsar 使用专门的 Cursor 管理。累积确认和 Kafka 效果一样；提供单条或选择性确认。

4. 消息保留

Kafka 根据设置的保留期来删除消息。有可能消息没被消费，过期后被删除。 不支持 TTL。

Pulsar 消息只有被所有订阅消费后才会删除，不会丢失数据。也允许设置保留期，保留被消费的数据。支持 TTL。

Apache Pulsar 将高性能的流（Apache Kafka 所追求的）和灵活的传统队列（RabbitMQ 所追求的）结合到一个统一的消息模型和 API 中。 Pulsar 使用统一的 API 为用户提供一个支持流和队列的系统，且具有同样的高性能。 应用程序可以将此统一的 API 用于高性能队列和流式传输，而无需维护两套系统：RabbitMQ 进行队列处理，Kafka 进行流式处理。Pulsar 更像是 kafka 性能和 rabbitmq 功能的合体。

### 消息持久化对比

从消息持久化方面对比，Pulsar 与 Kafka 有着很大的不同。

在 Apache Kafka 中，分区只能存储在单个节点上并复制到其他节点，其容量受最小节点容量的限制。这意味着容量扩展需要对分区重新平衡，这反过来又需要重新复制整个分区，以平衡新添加的代理的数据和流量。重新传输数据非常昂贵且容易出错，并且会消耗网络带宽和 I/O。维护人员在执行此操作时必须非常小心，以避免破坏生产系统。

Kafka 中分区数据的重新拷贝不仅发生在以分区为中心的系统中的群集扩展上。许多其他事情也会触发数据重新拷贝，例如副本故障，磁盘故障或计算机的故障。在数据重新复制期间，分区通常不可用，直到数据重新复制完成。例如，如果您将分区配置为存储为 3 个副本，这时，如果丢失了一个副本，则必须重新复制完整个分区后，分区才可以再次可用。

在用户遇到故障之前，通常会忽略这种缺陷，因为许多情况下，在短时间内仅是对内存中缓存数据的读取。当数据被保存到磁盘后，用户将越来越多地不可避免地遇到数据丢失，故障恢复的问题，特别是在需要将数据长时间保存的场合。

相反，在 Apache Pulsar 中，同样是以分区为逻辑单元，但是以 Segment 为物理存储单元。分区随着时间的推移会进行分段，并在整个集群中均衡分布，旨在有效地迅速地扩展。

Pulsar 是以 Segment 为中心的，因此在扩展容量时不需要数据重新平衡和拷贝，旧数据不会被重新复制，这要归功于在 Apache BookKeeper 中使用可扩展的以 Segment 为中心的分布式日志存储系统。

通过利用分布式日志存储，Pulsar 可以最大化 Segment 放置选项，实现高写入和高读取可用性。 例如，使用 BookKeeper，副本设置等于 2，只要任何 2 个 Bookie 启动，就可以对主题分区进行写入。 对于读取可用性，只要主题分区的副本集中有 1 个处于活动状态，用户就可以读取它，而不会出现任何不一致。

总之，Apache Pulsar 这种独特的基于分布式日志存储的以 Segment 为中心的发布/订阅消息系统可以提供许多优势，例如可靠的流式系统，包括无限制的日志存储，无需分区重新平衡的即时扩展，快速复制修复以及通过最大化数据放置实现高写入和读取可用性选项。


* https://www.infoq.cn/article/kafka-vs-rabbitmq
* https://www.infoq.cn/article/1uaxfkwuhukty1t_5gpq


